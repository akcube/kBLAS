#include <iostream>
#include <fstream>
#include <random>
#include <cblas.h>
#include <map>
#include <string.h>

/**
 * We trust the outputs from the CBLAS library to be accurate.
 */

// -----------------------------------------------------------------------------------
// 							Random data generation
// -----------------------------------------------------------------------------------
std::random_device rd;  // Will be used to obtain a seed for the random number engine
std::mt19937 gen; // Standard mersenne_twister_engine which we will seed with rd()
/**
 * Create a `std::uniform_real_distribution<T> dis(l, r)`, then
 * use dis to transform the random unsigned int generated by gen into a 
 * double in [l, r). Each call to dis(gen) generates a new random type T
 */

// -----------------------------------------------------------------------------------
// 							Matrix generation
// -----------------------------------------------------------------------------------
/**
 * Creates a matrix of type T, dimensions MxN and returns a pointer to malloc'd memory. 
 * Can additionally pass arguments l and r to specify a range to generate random 
 * numbers between.
 */
template<typename T>
T* create_rand_matrix(int M, int N, T l = 0.0, T r = 1e6){
    std::uniform_real_distribution<T> dis(l, r);
	T *mat = (T*) malloc(sizeof(T) * M * N);
	for(int i=0; i<(M*N); i++) mat[i] = dis(gen);
	return mat;
}

/**
 * Returns a random number of type T. Can additionally pass arguments l and r to 
 * specify a range to generate random numbers between.
 */
template<typename T>
T get_rand_num(T l = 0.0, T r = 1e6){
    std::uniform_real_distribution<T> dis(l, r);
    return dis(gen);
}

// -----------------------------------------------------------------------------------
// 							Benchmark code
// -----------------------------------------------------------------------------------

typedef std::vector<std::pair<int, int>> vii;
#define ss second
#define ff first
std::map<std::string, std::vector<vii>> config;

void __init(){
	// Initialize the mersenne twister engine
	gen = std::mt19937(rd());

	// Load config options into the config map
	/**
	 * The goal here is to benchmark the functions for varying sizes in memory. Ultimately
	 * memory will end up becoming the benchmark for large vector / matrix operations.
	 * Here is a reasonable guide to picking config sizes: 
	 * + 1-3 options should fit in L1-L2 cache
	 * + 4-6 options should fit in L2-L3 cache
	 * + 7-9 options should overflow cache and start occupying large amounts of system memory
	 * 
	 * Tip: For the double versions of benchmarks, simply half the memory usage of the float versions
	 */
	
	config["sscal"] = 	{{{1, 1}, {1, 12800}}, {{1, 1}, {1, 25600}}, {{1, 1}, {1, 76800}}, \
						 {{1, 1}, {1, 153600}}, {{1, 1}, {1, 307200}}, {{1, 1}, {1, 524288}}, \
						 {{1, 1}, {1, 1310720}}, {{1, 1}, {1, 2097152}}, {{1, 1}, {1, 3145728}}, \
						 {{1, 1}, {1, 4194304}}, {{1, 1}, {1, 5242880}}, {{1, 1}, {1, 8388608}}, \
						 {{1, 1}, {1, 16777216}}, {{1, 1}, {1, 33554432}}, {{1, 1}, {1, 67108864}}, \
						 {{1, 1}, {1, 134217728}}, {{1, 1}, {1, 268435456}}};

	config["dscal"] = 	{{{1, 1}, {1, 6400}}, {{1, 1}, {1, 12800}}, {{1, 1}, {1, 38400}}, \
						 {{1, 1}, {1, 76800}}, {{1, 1}, {1, 153600}}, {{1, 1}, {1, 262144}}, \
						 {{1, 1}, {1, 655360}}, {{1, 1}, {1, 1048576}}, {{1, 1}, {1, 1572864}}, \
						 {{1, 1}, {1, 2097152}}, {{1, 1}, {1, 2621440}}, {{1, 1}, {1, 4194304}}, \
						 {{1, 1}, {1, 8388608}}, {{1, 1}, {1, 16777216}}, {{1, 1}, {1, 33554432}}, \
						 {{1, 1}, {1, 67108864}}, {{1, 1}, {1, 134217728}}};

	config["sdot"] = 	{{{1, 6400}, {1, 6400}}, {{1, 12800}, {1, 12800}}, {{1, 38400}, {1, 38400}}, \
						 {{1, 76800}, {1, 76800}}, {{1, 153600}, {1, 153600}}, {{1, 262144}, {1, 262144}}, \
						 {{1, 655360}, {1, 655360}}, {{1, 1048576}, {1, 1048576}}, {{1, 1572864}, {1, 1572864}}, \
						 {{1, 2097152}, {1, 2097152}}, {{1, 2621440}, {1, 2621440}}, {{1, 4194304}, {1, 4194304}}, \
						 {{1, 8388608}, {1, 8388608}}, {{1, 16777216}, {1, 16777216}}, {{1, 33554432}, {1, 33554432}}, \
						 {{1, 67108864}, {1, 67108864}}, {{1, 134217728}, {1, 134217728}}};

	config["ddot"] = 	{{{1, 3200}, {1, 3200}}, {{1, 6400}, {1, 6400}}, {{1, 19200}, {1, 19200}}, \
						 {{1, 38400}, {1, 38400}}, {{1, 76800}, {1, 76800}}, {{1, 131072}, {1, 131072}}, \
						 {{1, 327680}, {1, 327680}}, {{1, 524288}, {1, 524288}}, {{1, 786432}, {1, 786432}}, \
						 {{1, 1048576}, {1, 1048576}}, {{1, 1310720}, {1, 1310720}}, {{1, 2097152}, {1, 2097152}}, \
						 {{1, 4194304}, {1, 4194304}}, {{1, 8388608}, {1, 8388608}}, {{1, 16777216}, {1, 16777216}}, \
						 {{1, 33554432}, {1, 33554432}}, {{1, 67108864}, {1, 67108864}}};
}

/**
 * Given the config, creates the requested spec and then writes it to the fs filestream
 */
template<typename T>
void write_config(vii &conf, std::fstream &fs){
	for(auto [n, m]:conf){
		fs.write((const char*) &n, sizeof(int));
		fs.write((const char*) &m, sizeof(int));
		T *elem = (T*) create_rand_matrix<T>(n, m);
		fs.write((const char*) elem, sizeof(T)*n*m);
		free(elem);
	}
}

/**
 * Given an input filestream fs, reads in arguments of the form 
 * std::pair<int, int> dim, n*m matrix of floats or doubles.
 */
template<typename T>
std::vector<std::pair<T*, std::pair<int, int>>> parse_input(std::ifstream &fs){
	int n, m;
	std::vector<std::pair<T*, std::pair<int, int>>> ret;
	while(!fs.eof()){
		n = -1;
		fs.read((char*) &n, sizeof(int));
		if(n == -1) break;
		fs.read((char*) &m, sizeof(int));
		T *elem = (T*) malloc(sizeof(T)*n*m);
		fs.read((char*) elem, sizeof(T)*n*m);
		ret.push_back({elem, {n, m}});
	}
	return ret;
}

/**
 * Writes the generated result matrix to filestream fs
 */
template<typename T>
void write_verification(std::fstream &fs, int N, int M, T *data){
	fs.write((const char*) data, sizeof(T) * N * M);
}

template<typename T>
void _scal_verify(std::ifstream &ifs, std::fstream &ofs, void (*fun)(int, T, T*, int));
template<typename T>
void _dot_verify(std::ifstream &ifs, std::fstream &ofs, T (*dot)(int, const T*, int, const T*, int));

#define INPUT_DIR "input/"
#define VERIF_DIR "verification/"

int main(void){
	__init();

	// Generate input data from config
	for(auto &[benchmark, confs]:config){
		int num_confs = confs.size();
		for(int i=0; i<num_confs; i++){
			std::cout<<"["<<i+1<<"/"<<num_confs<<"]\tGenerating input files for "<<benchmark<<"\n";
			std::fstream fs(INPUT_DIR + benchmark + "/" + std::to_string(i+1),  std::ios::out | std::ios::binary);
			if(benchmark[0] == 's') write_config<float>(confs[i], fs);
			else if(benchmark[0] == 'd') write_config<double>(confs[i], fs);
		}
	}

	// Generate verification data by running CBLAS on it and saving result
	for(auto &[benchmark, confs]:config){
		int num_confs = confs.size();
		for(int i=0; i<num_confs; i++){
			std::cout<<"["<<i+1<<"/"<<num_confs<<"]\tRunning CBLAS on input file for "<<benchmark<<"\n";
			std::ifstream ifs(INPUT_DIR + benchmark + "/" + std::to_string(i+1),  std::ios::out | std::ios::binary);
			std::fstream ofs(VERIF_DIR + benchmark + "/" + std::to_string(i+1),  std::ios::out | std::ios::binary);
			if 		(benchmark == "sscal") _scal_verify(ifs, ofs, cblas_sscal);
			else if (benchmark == "dscal") _scal_verify(ifs, ofs, cblas_dscal);
			else if (benchmark == "sdot") _dot_verify(ifs, ofs, cblas_sdot);
			else if (benchmark == "ddot") _dot_verify(ifs, ofs, cblas_ddot);
		}
	}
}

template<typename T>
void _scal_verify(std::ifstream &ifs, std::fstream &ofs, void (*scal)(int, T, T*, int)){
	std::vector<std::pair<T*, std::pair<int, int>>> args = parse_input<T>(ifs);
	T alpha = *(args[0].ff);
	int N = args[1].ss.ss;
	T *X = args[1].ff;
	scal(N, alpha, X, 1);
	write_verification<T>(ofs, 1, N, X);
	for(auto &arg:args) free(arg.ff);
}

template<typename T>
void _dot_verify(std::ifstream &ifs, std::fstream &ofs, T (*dot)(int, const T*, int, const T*, int)){
	std::vector<std::pair<T*, std::pair<int, int>>> args = parse_input<T>(ifs);
	int N = args[0].ss.ss;
	T *X = args[0].ff, *Y = args[1].ff;
	T result = dot(N, X, 1, Y, 1);
	write_verification<T>(ofs, 1, 1, &result);
	for(auto &arg:args) free(arg.ff);
}